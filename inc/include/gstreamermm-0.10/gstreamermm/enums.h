// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GSTREAMERMM_ENUMS_H
#define _GSTREAMERMM_ENUMS_H


#include <glibmm.h>

/* gstreamermm - a C++ wrapper for gstreamer
 *
 * Copyright 2008 The gstreamermm Development Team
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free
 * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <gst/gstminiobject.h>
#include <gst/gstelement.h>


// Plug-in C enums used in the plug-in signals that are shared need to be
// declared.  This one is is shared between decodebin2 and uridecodebin so it
// is difficult for it to be generated.
enum GstAutoplugSelectResult
{
  GST_AUTOPLUG_SELECT_TRY,
  GST_AUTOPLUG_SELECT_EXPOSE,
  GST_AUTOPLUG_SELECT_SKIP
};

namespace Gst
{

/** @addtogroup gstreamermmEnums gstreamermm Enums and Flags */

/**
 * @ingroup gstreamermmEnums
 * @par Bitwise operators:
 * <tt>%MiniObjectFlags operator|(MiniObjectFlags, MiniObjectFlags)</tt><br>
 * <tt>%MiniObjectFlags operator&(MiniObjectFlags, MiniObjectFlags)</tt><br>
 * <tt>%MiniObjectFlags operator^(MiniObjectFlags, MiniObjectFlags)</tt><br>
 * <tt>%MiniObjectFlags operator~(MiniObjectFlags)</tt><br>
 * <tt>%MiniObjectFlags& operator|=(MiniObjectFlags&, MiniObjectFlags)</tt><br>
 * <tt>%MiniObjectFlags& operator&=(MiniObjectFlags&, MiniObjectFlags)</tt><br>
 * <tt>%MiniObjectFlags& operator^=(MiniObjectFlags&, MiniObjectFlags)</tt><br>
 */
enum MiniObjectFlags
{
  MINI_OBJECT_FLAG_READONLY = (1<<0),
  MINI_OBJECT_FLAG_RESERVED1 = (1<<1),
  MINI_OBJECT_FLAG_LAST = (1<<4)
};

/** @ingroup gstreamermmEnums */
inline MiniObjectFlags operator|(MiniObjectFlags lhs, MiniObjectFlags rhs)
  { return static_cast<MiniObjectFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs)); }

/** @ingroup gstreamermmEnums */
inline MiniObjectFlags operator&(MiniObjectFlags lhs, MiniObjectFlags rhs)
  { return static_cast<MiniObjectFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs)); }

/** @ingroup gstreamermmEnums */
inline MiniObjectFlags operator^(MiniObjectFlags lhs, MiniObjectFlags rhs)
  { return static_cast<MiniObjectFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs)); }

/** @ingroup gstreamermmEnums */
inline MiniObjectFlags operator~(MiniObjectFlags flags)
  { return static_cast<MiniObjectFlags>(~static_cast<unsigned>(flags)); }

/** @ingroup gstreamermmEnums */
inline MiniObjectFlags& operator|=(MiniObjectFlags& lhs, MiniObjectFlags rhs)
  { return (lhs = static_cast<MiniObjectFlags>(static_cast<unsigned>(lhs) | static_cast<unsigned>(rhs))); }

/** @ingroup gstreamermmEnums */
inline MiniObjectFlags& operator&=(MiniObjectFlags& lhs, MiniObjectFlags rhs)
  { return (lhs = static_cast<MiniObjectFlags>(static_cast<unsigned>(lhs) & static_cast<unsigned>(rhs))); }

/** @ingroup gstreamermmEnums */
inline MiniObjectFlags& operator^=(MiniObjectFlags& lhs, MiniObjectFlags rhs)
  { return (lhs = static_cast<MiniObjectFlags>(static_cast<unsigned>(lhs) ^ static_cast<unsigned>(rhs))); }

} // namespace Gst


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::MiniObjectFlags> : public Glib::Value_Flags<Gst::MiniObjectFlags>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{

/**
 * @ingroup gstreamermmEnums
 */
enum State
{
  STATE_VOID_PENDING,
  STATE_NULL,
  STATE_READY,
  STATE_PAUSED,
  STATE_PLAYING
};

} // namespace Gst


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::State> : public Glib::Value_Enum<Gst::State>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{


// Plug-in non-genereated enums.  Handled manually and not generated because
// they are shared by more than one plug-in:
/**
 * @ingroup gstreamermmEnums
 */
enum AutoplugSelectResult
{
  AUTOPLUG_SELECT_TRY,
  AUTOPLUG_SELECT_EXPOSE,
  AUTOPLUG_SELECT_SKIP
};

} // namespace Gst


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::AutoplugSelectResult> : public Glib::Value_Enum<Gst::AutoplugSelectResult>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{

/**
 * @ingroup gstreamermmEnums
 */
enum TCPProtocol
{
  TCP_PROTOCOL_NONE,
  TCP_PROTOCOL_GDP
};

} // namespace Gst


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::TCPProtocol> : public Glib::Value_Enum<Gst::TCPProtocol>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{


} //namespace Gst


#endif /* _GSTREAMERMM_ENUMS_H */

