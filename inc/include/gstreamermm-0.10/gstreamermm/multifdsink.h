// -*- c++ -*-
// Generated by gtkmmproc -- DO NOT MODIFY!
#ifndef _GSTREAMERMM_MULTIFDSINK_H
#define _GSTREAMERMM_MULTIFDSINK_H


#include <glibmm.h>

// Generated by generate_plugin_gmmproc_file. Don't edit this file.


#include <gstreamermm/basesink.h>
#include <gstreamermm/enums.h>
#include <glibmm/valuearray.h>


// Plug-in C enums used in signals:
enum GstSyncMethod
{
  GST_SYNC_METHOD_LATEST = 0,
  GST_SYNC_METHOD_NEXT_KEYFRAME = 1,
  GST_SYNC_METHOD_LATEST_KEYFRAME = 2,
  GST_SYNC_METHOD_BURST = 3,
  GST_SYNC_METHOD_BURST_KEYFRAME = 4,
  GST_SYNC_METHOD_BURST_WITH_KEYFRAME = 5
};

enum GstTCPUnitType
{
  GST_TCP_UNIT_TYPE_UNDEFINED = 0,
  GST_TCP_UNIT_TYPE_BUFFERS = 1,
  GST_TCP_UNIT_TYPE_BYTES = 3,
  GST_TCP_UNIT_TYPE_TIME = 2
};

enum GstClientStatus
{
  GST_CLIENT_STATUS_OK = 0,
  GST_CLIENT_STATUS_CLOSED = 1,
  GST_CLIENT_STATUS_REMOVED = 2,
  GST_CLIENT_STATUS_SLOW = 3,
  GST_CLIENT_STATUS_ERROR = 4,
  GST_CLIENT_STATUS_DUPLICATE = 5,
  GST_CLIENT_STATUS_FLUSHING = 6
};

#ifndef DOXYGEN_SHOULD_SKIP_THIS
typedef struct _GstMultiFdSink GstMultiFdSink;
typedef struct _GstMultiFdSinkClass GstMultiFdSinkClass;
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{ class MultiFdSink_Class; } // namespace Gst
namespace Gst
{

/** @addtogroup gstreamermmEnums gstreamermm Enums and Flags */

/**
 * @ingroup gstreamermmEnums
 */
enum FDSetMode
{
  FD_SET_MODE_SELECT,
  FD_SET_MODE_POLL,
  FD_SET_MODE_EPOLL
};

} // namespace Gst


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::FDSetMode> : public Glib::Value_Enum<Gst::FDSetMode>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{


/**
 * @ingroup gstreamermmEnums
 */
enum TCPUnitType
{
  TCP_UNIT_TYPE_UNDEFINED,
  TCP_UNIT_TYPE_BUFFERS,
  TCP_UNIT_TYPE_TIME,
  TCP_UNIT_TYPE_BYTES
};

} // namespace Gst


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::TCPUnitType> : public Glib::Value_Enum<Gst::TCPUnitType>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{


/**
 * @ingroup gstreamermmEnums
 */
enum RecoverPolicy
{
  RECOVER_POLICY_NONE,
  RECOVER_POLICY_RESYNC_LATEST,
  RECOVER_POLICY_RESYNC_SOFT_LIMIT,
  RECOVER_POLICY_RESYNC_KEYFRAME
};

} // namespace Gst


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::RecoverPolicy> : public Glib::Value_Enum<Gst::RecoverPolicy>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{


/**
 * @ingroup gstreamermmEnums
 */
enum SyncMethod
{
  SYNC_METHOD_LATEST,
  SYNC_METHOD_NEXT_KEYFRAME,
  SYNC_METHOD_LATEST_KEYFRAME,
  SYNC_METHOD_BURST,
  SYNC_METHOD_BURST_KEYFRAME,
  SYNC_METHOD_BURST_WITH_KEYFRAME
};

} // namespace Gst


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::SyncMethod> : public Glib::Value_Enum<Gst::SyncMethod>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{


/**
 * @ingroup gstreamermmEnums
 */
enum ClientStatus
{
  CLIENT_STATUS_OK,
  CLIENT_STATUS_CLOSED,
  CLIENT_STATUS_REMOVED,
  CLIENT_STATUS_SLOW,
  CLIENT_STATUS_ERROR,
  CLIENT_STATUS_DUPLICATE,
  CLIENT_STATUS_FLUSHING
};

} // namespace Gst


#ifndef DOXYGEN_SHOULD_SKIP_THIS
namespace Glib
{

template <>
class Value<Gst::ClientStatus> : public Glib::Value_Enum<Gst::ClientStatus>
{
public:
  static GType value_type() G_GNUC_CONST;
};

} // namespace Glib
#endif /* DOXYGEN_SHOULD_SKIP_THIS */


namespace Gst
{


/** A Wrapper for the multifdsink plugin.
 * Please note that, though using the underlying GObject is fine, using its C
 * <B>type</B> is not guaranteed to be API stable across releases because it is
 * not guaranteed to always remain the same.  Also, not all plug-ins are
 * available on all systems so care must be taken that they exist before they
 * are used, otherwise there will be errors and possibly a crash.
 *
 * @ingroup GstPlugins
 */

class MultiFdSink
: public Gst::BaseSink
{
  
#ifndef DOXYGEN_SHOULD_SKIP_THIS

public:
  typedef MultiFdSink CppObjectType;
  typedef MultiFdSink_Class CppClassType;
  typedef GstMultiFdSink BaseObjectType;
  typedef GstMultiFdSinkClass BaseClassType;

private:  friend class MultiFdSink_Class;
  static CppClassType multifdsink_class_;

private:
  // noncopyable
  MultiFdSink(const MultiFdSink&);
  MultiFdSink& operator=(const MultiFdSink&);

protected:
  explicit MultiFdSink(const Glib::ConstructParams& construct_params);
  explicit MultiFdSink(GstMultiFdSink* castitem);

#endif /* DOXYGEN_SHOULD_SKIP_THIS */

public:
  virtual ~MultiFdSink();

#ifndef DOXYGEN_SHOULD_SKIP_THIS
  static GType get_type()      G_GNUC_CONST;


  static GType get_base_type() G_GNUC_CONST;
#endif

  ///Provides access to the underlying C GObject.
  GstMultiFdSink*       gobj()       { return reinterpret_cast<GstMultiFdSink*>(gobject_); }

  ///Provides access to the underlying C GObject.
  const GstMultiFdSink* gobj() const { return reinterpret_cast<GstMultiFdSink*>(gobject_); }

  ///Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.
  GstMultiFdSink* gobj_copy();

private:

  
protected:
  MultiFdSink();
  explicit MultiFdSink(const Glib::ustring& name);

public:
  /** Creates a new multifdsink plugin with a unique name.
   */
  
  static Glib::RefPtr<MultiFdSink> create();


  /** Creates a new multifdsink plugin with the given name.
   */
  
  static Glib::RefPtr<MultiFdSink> create(const Glib::ustring& name);


  /** This is a convenience method for the action signal
   * signal_add().
   */
  void add(int arg0);

  /** This is a convenience method for the action signal
   * signal_add_full().
   */
  void add_full(int arg0, Gst::SyncMethod arg1, Gst::TCPUnitType arg2, guint64 arg3, Gst::TCPUnitType arg4, guint64 arg5);

  /** This is a convenience method for the action signal
   * signal_remove().
   */
  void remove(int arg0);

  /** This is a convenience method for the action signal
   * signal_remove_flush().
   */
  void remove_flush(int arg0);

  /** This is a convenience method for the action signal
   * signal_clear().
   */
  void clear();

  /** This is a convenience method for the action signal
   * signal_get_stats().
   */
  Glib::ValueArray get_stats(int arg0);


  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The protocol to wrap data in. GDP protocol here is deprecated. Please use gdppay element.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<Gst::TCPProtocol> property_protocol() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The protocol to wrap data in. GDP protocol here is deprecated. Please use gdppay element.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<Gst::TCPProtocol> property_protocol() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The mode for selecting activity on the fds (deprecated).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<Gst::FDSetMode> property_mode() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The mode for selecting activity on the fds (deprecated).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<Gst::FDSetMode> property_mode() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** Number of buffers currently queued.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint> property_buffers_queued() const;
#endif //#GLIBMM_PROPERTIES_ENABLED


  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The unit to measure the max/soft-max/queued properties.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<Gst::TCPUnitType> property_unit_type() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The unit to measure the max/soft-max/queued properties.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<Gst::TCPUnitType> property_unit_type() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** max number of units to queue (-1 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<gint64> property_units_max() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** max number of units to queue (-1 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<gint64> property_units_max() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** Recover client when going over this limit (-1 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<gint64> property_units_soft_max() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** Recover client when going over this limit (-1 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<gint64> property_units_soft_max() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** max number of buffers to queue for a client (-1 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<int> property_buffers_max() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** max number of buffers to queue for a client (-1 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<int> property_buffers_max() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** Recover client when going over this limit (-1 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<int> property_buffers_soft_max() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** Recover client when going over this limit (-1 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<int> property_buffers_soft_max() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** min number of time to queue (-1 = as little as possible).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<gint64> property_time_min() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** min number of time to queue (-1 = as little as possible).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<gint64> property_time_min() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** min number of bytes to queue (-1 = as little as possible).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<int> property_bytes_min() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** min number of bytes to queue (-1 = as little as possible).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<int> property_bytes_min() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** min number of buffers to queue (-1 = as few as possible).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<int> property_buffers_min() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** min number of buffers to queue (-1 = as few as possible).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<int> property_buffers_min() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** How to recover when client reaches the soft max.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<Gst::RecoverPolicy> property_recover_policy() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** How to recover when client reaches the soft max.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<Gst::RecoverPolicy> property_recover_policy() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** Maximum inactivity timeout in nanoseconds for a client (0 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<guint64> property_timeout() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** Maximum inactivity timeout in nanoseconds for a client (0 = no limit).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint64> property_timeout() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** How to sync new clients to the stream.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<Gst::SyncMethod> property_sync_method() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** How to sync new clients to the stream.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<Gst::SyncMethod> property_sync_method() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** Number of bytes received to serve to clients.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint64> property_bytes_to_serve() const;
#endif //#GLIBMM_PROPERTIES_ENABLED


  #ifdef GLIBMM_PROPERTIES_ENABLED
/** Total number of bytes send to all clients.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint64> property_bytes_served() const;
#endif //#GLIBMM_PROPERTIES_ENABLED


  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The format of the burst units (when sync-method is burst[[-with]-keyframe]).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<Gst::TCPUnitType> property_burst_unit() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The format of the burst units (when sync-method is burst[[-with]-keyframe]).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<Gst::TCPUnitType> property_burst_unit() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The amount of burst expressed in burst-unit.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<guint64> property_burst_value() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** The amount of burst expressed in burst-unit.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint64> property_burst_value() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** Quality of Service, differentiated services code point (-1 default).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<int> property_qos_dscp() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** Quality of Service, differentiated services code point (-1 default).
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<int> property_qos_dscp() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** Handle client reads and discard the data.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<bool> property_handle_read() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** Handle client reads and discard the data.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<bool> property_handle_read() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** Resend the streamheader if it changes in the caps.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy<bool> property_resend_streamheader() ;
#endif //#GLIBMM_PROPERTIES_ENABLED

#ifdef GLIBMM_PROPERTIES_ENABLED
/** Resend the streamheader if it changes in the caps.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<bool> property_resend_streamheader() const;
#endif //#GLIBMM_PROPERTIES_ENABLED

  #ifdef GLIBMM_PROPERTIES_ENABLED
/** The current number of client file descriptors.
   *
   * You rarely need to use properties because there are get_ and set_ methods for almost all of them.
   * @return A PropertyProxy that allows you to get or set the property of the value, or receive notification when
   * the value of the property changes.
   */
  Glib::PropertyProxy_ReadOnly<guint> property_num_fds() const;
#endif //#GLIBMM_PROPERTIES_ENABLED


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, add().
   *
   * @par Prototype:
   * <tt>void on_my_%add(int arg0)</tt>
   */

  Glib::SignalProxy1< void,int > signal_add();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, add_full().
   *
   * @par Prototype:
   * <tt>void on_my_%add_full(int arg0, Gst::SyncMethod arg1, Gst::TCPUnitType arg2, guint64 arg3, Gst::TCPUnitType arg4, guint64 arg5)</tt>
   */

  Glib::SignalProxy6< void,int,Gst::SyncMethod,Gst::TCPUnitType,guint64,Gst::TCPUnitType,guint64 > signal_add_full();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, remove().
   *
   * @par Prototype:
   * <tt>void on_my_%remove(int arg0)</tt>
   */

  Glib::SignalProxy1< void,int > signal_remove();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, remove_flush().
   *
   * @par Prototype:
   * <tt>void on_my_%remove_flush(int arg0)</tt>
   */

  Glib::SignalProxy1< void,int > signal_remove_flush();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, clear().
   *
   * @par Prototype:
   * <tt>void on_my_%clear()</tt>
   */

  Glib::SignalProxy0< void > signal_clear();


  /** This is an action signal which is designed to be used as a method.  To 
   * do that, use its convenience method, get_stats().
   *
   * @par Prototype:
   * <tt>Glib::ValueArray on_my_%get_stats(int arg0)</tt>
   */

  Glib::SignalProxy1< Glib::ValueArray,int > signal_get_stats();


  /**
   * @par Prototype:
   * <tt>void on_my_%client_added(int arg0)</tt>
   */

  Glib::SignalProxy1< void,int > signal_client_added();

  
  /**
   * @par Prototype:
   * <tt>void on_my_%client_removed(int arg0, Gst::ClientStatus arg1)</tt>
   */

  Glib::SignalProxy2< void,int,Gst::ClientStatus > signal_client_removed();

  
  /**
   * @par Prototype:
   * <tt>void on_my_%client_fd_removed(int arg0)</tt>
   */

  Glib::SignalProxy1< void,int > signal_client_fd_removed();


public:

public:
  //C++ methods used to invoke GTK+ virtual functions:

protected:
  //GTK+ Virtual Functions (override these to change behaviour):

  //Default Signal Handlers::


};

} // namespace Gst


namespace Glib
{
  /** A Glib::wrap() method for this object.
   * 
   * @param object The C instance.
   * @param take_copy False if the result should take ownership of the C instance. True if it should take a new copy or ref.
   * @result A C++ instance that wraps this C instance.
   *
   * @relates Gst::MultiFdSink
   */
  Glib::RefPtr<Gst::MultiFdSink> wrap(GstMultiFdSink* object, bool take_copy = false);
}


#endif /* _GSTREAMERMM_MULTIFDSINK_H */

